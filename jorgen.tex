% !TEX encoding = UTF-8 Unicode
% !TEX root = thesis.tex
% !TEX spellcheck = en-US
%%=========================================
\chapter[Web Application vulnerabilities in 2016]{Common vulnerabilities and attack surfaces for Web Applications in 2016}

\subsection*{Management summary}
The web stack has evolved to serve feature rich and dynamic experiences within the browser by expanding on the legacy applications. The majority of cyber attacks are done at web application level, and most of the vulnerabilities are well known and documented - but alot of web applications fail to mitigate or counteract them.

In this chapter several reports from security companies and non-profit organizations was analyzed to find some of the most common web application vulnerabilities with the possibility of severe consequences. The chapter focuses on Cross-Site Scripting, SQL Injection and vulnerable JavaScript Libraries to explain how they work and how they can harm the companies and their visitors/clients. It briefly looks at the rising usage of Exploit Kits, and how these vulnerabilities can compromize the web application and make it a part of an Exploit Kit infrastructure. It continues to look at possible mitigation techniqes and countermeasurements and discuss why so many sites are vulnerable to these well-known attack surfaces.
%%=========================================
\pagebreak
\section{Introduction}
Over the last years web application hacking has increased, and as many as 75\% of cyber attacks are done at web applications level or via the web \cite{AcunetixCompany}. The introduction in the Acunetix report states that 55\% of web applications has atleast one high-severity vulnerability - and thats up 9\% since 2015.

The web stack has evolved to serve feature rich and dynamic experiences within the browser by expanding on the legacy applications. This has widened the attackers oppertunities, and the amount of vulnerable applications on the web is ever increasing \cite{Acunetix2016}. In recent years an alarming number of high profile web service providers has lost huge amounts of personal data, including emails and weakly hashed passwords. \\ This chapter aims to find the most common vulnerabilities and attack surfaces for web applications in 2016, what the consequences can be, what measures can be taken, and hopefully a hint to why so many web applications are still vulnerable.
\\ \\
This chapter will focus on the application code vulnerabilities that might arise from poor programming and vulnerable third-party libraries in the application itself. A combination of the results of four induvidual information security reports will be examined to find a few vulnerabilities that occur often and are of high severity. Three of the reports are from 2015/2016, and the fourth is OWASP Top 10 from 2013. 
\subsubsection{OWASP Top 10}
Open Web Application Security Project is a international charitable non-profit organization, and is a colaberation between a varity of security experts around the world \cite{OwaspCompany}. The primary aim of the OWASP Top 10 is to raise awareness for web application security, and so far the report has been released twice, in 2010 and 2013 \cite{OwaspTop10Project}.
\subsubsection{Acunetix Web Application Vulnerability Report 2016}
Acunetix is a company spacializing in automated tools to scan servers for vulnerabilities, and have many high profile private and public companies as clients \cite{AcunetixCompany}. They released an annual report on statistics from their scans throughout the period of 1st April 2015 to 31st March 2016. Acunetix has gathered, aggretated and analyzed data from over 61.000 scans over a two year period, and are in a great position to observe trends in the field \cite{Acunetix2016}. 
\subsubsection{Hewlett Packard Enterprise Security Research Cyber Risk Report 2016}
Hewlett Packard provide a broad view of the 2015 threat landscape, based on industry-wide data and a focused look at open source, mobile and IoT \cite{HP2016}.
\subsubsection{Symantec Internet Security Threat Report 2016}
Through the Global Intelligence Network, Symantec has one of the most comprehensive sources of internet threat data \cite{Symantec2016}. It's made up of more than 63.8 million attack sensors in over 157 countries and territories through a combination of Symantec products and services \cite{Symantec2016}.
\pagebreak
\section{Trending vulnerabilities and consequences}
This section will introduce the three common high-severity vulnerabilities that this chapter will focus on. By examinin the reports listed in the Introduction, the choice has fallen on Cross-Site Scripting (XSS), SQL Injections and Vulnerable JavaScript libraries. All of the threats described here have consistently been reported as the most common vulnerabilities in web applications for several years, and 2016 is no different \cite{OWASP2010}\cite{OWASP2013}\cite{Acunetix2016}. They are all vulnerabilities that arise in the development phase of a web application, and they can all potentially cause significant damage. 
\subsection{Cross-Site Scripting (XSS)}
If an attacker is able to submit malicious HTML such as JavaScript to a dynamic web application, they are able to execute a Cross-Site Scripting, or XSS, attack \cite{Kirda2011}. \\
Unlike traditional distributed systems security where access control equals authentication and authorisation, a web application uses the same-origin policy \cite{Gollmann2011}. This policy is exploited by a Cross-Site Scripting attack, when the vulnerable site is viewed by a victim the malicious content seems to come from the trused site, and the attacker can steal cookies, session identefiers and other sensetive information that the web site has access to \cite{Kirda2011}. Cross-Site Scripting can be viewed as two categories, Persistent and Non-persistent attacks. In a persistent attack the attacker is able to store some malicous code in the database or a file that are rendered as part of the website for future visitors \cite{Edmunds2016}. In a non-persistent attack the attacker uses parameters in the url to inject malicious code to the server, potentally deleting or disclosing sensitive information \cite{Edmunds2016}.
\\ \\
Consider the following scenario:
A user connects to \textit{trusted.com} where they are a registered and authenticated user. In \textit{trusted.com/forum} a malicious user has posted a seemingly innocent post, but managed to append some unsanatized JavaScript code at the end of the post. The JavaScript snippet is not visually rendered by the browser, but executed in the background. The JavaScript snippet then sends the cookie of the victim to \textit{malicious.com/save?cookie=} and append the cookie for storage.

A twitter tool called TweetDeck had a serious Cross Site Scripting vulnerability in 2014 that made it possible to tweet unsanitized input \cite{TweetDeck}. This was a self retweeting tweet, with a small red heart as the only visible content. Lets look at the code as it was injected:
\begin{quote}
\fontfamily{cmtt}\selectfont
{$<$script class="xss"$>$\$(`.xss`).parents().eq(1).find(`a`).eq(1).click() \\ ;\$(`[data-action=retweet]`).click();alert(`XXS in TweetDeck`)$<$/script$>$}
\end{quote}
If we examine the code in this attack, it starts out by opening a \textit{script} tag and giving it a css class called \textit{xxs} to be able to use it as an reference. The \$ refers to jQuery, a popular JavaScript Library, and uses the class previously created to locate the parent containers. Then it picks the second parent out of the list of parents, which in this case is the tweet box. It then continues to find all the link tags and again select the second one, which in this case is the retweet button - and clicks it. This in turn opens a popup to confirm the retweet and the next jQuery tag clicks on the comfirm tweet button, or \textit{[data-action=retweet]}. It finally promts the user with a JavaScript alert saying \textit{"XXS in TweetDeck"} and closes off the script tag.

Now this is a fairly innocent attack, and you could argue that this attacker did this to either show of their skills or alert the twitter developers of their error - or even both. There is no reason to alert the user if you want this to go unnoticed as long as possible, so it's safe to assume that this vulnerability could have caused alot more damage if the attacker wanted to.
\\ \\
Both of these previous examples are so-called persistent attacks. The malicious code is stored on the server to render for all visitors. An example of a non-persistent attack could be a page taking page number as a parameter in the url, where the attacker can send malicious code as a parameter - and then somehow get the victim to visit that url while authenticated \cite{Edmunds2016}.
\subsection{SQL Injection}
Structured Query Language (SQL) is the language enabeling applications to talk to most relational databases. In a web application scenario SQL is used for creating, reading, updating, and deleting, in addition to searching and filtration. It is often connected to forms and other dynamic user input functionality, and this is where most SQL-Injection attacks come into play. If an attacker is able to inject code that the server treats as SQL code, the attacker can gain access to the underlying database \cite{Bisson2005}. Databases often contain sensitive consumer or user information, and result in violations such as identity theft, loss of confidensial information, fraud and even system control.
\\ This could possibly work on any website or web application that uses a SQL-based database, and is therefore one of the oldest, most prevalent and dangerous vulnerabilities \cite{Acunetix2016}.
\subsection{Vulnerable JavaScript Libraries}
JavaScript has become the number one client-side language for user-friendly content display, and does often communicate with backend languages through Asynchronous Javascript And Xml (AJAX). A library in programming terms is a pre-written set of code to ease the development of applications, and is used by most dynamic websites today. One of the challenges that arises from this approach is that when a vulnerability is exposed by an attacker, a large number of sites suffer from the same vulnerability.
27\% of the sampled targets in Acunetix Web Application Vulnerability Report 2016 used vulnerable JavaScript libraries within their application \cite{Acunetix2016}. 
\subsection{Exploit Kits}
Vulnerabilities compromising a site could lead to the site being a part of an Exploit Kit infrastructure. Exploit Kits are server applications made to deliver malware istead of web content \cite{Preuss2011}. They are not a web application vulnerability in themselves, but a tool used for drive-by-download attacks through a multitude of vulnerabilities in browsers and browser addons packaged together in a kit \cite{Kotov2013}. The reason exploit kits get a mention here in this report is that they can be a result of the three vulnerabilities mentioned above, for example an $<$iframe$>$ in a XSS or even a SQLInjection or a JavaScript based redirect \cite{Preuss2011}.
The exploit kits inject shellcode to the vicim process to download a independent malware executable to the victim's hard drive and executes it \cite{Preuss2011}.
These kits has become a competative market and range from several hundreds to over a thousands dollar on the black market \cite{Preuss2011}, and therefore also have sophisticated code and sometimes even zero-day exploits.
\pagebreak
\section{Countermeasures and mitigation}
Losing sensetive information, about your users or your own systems, is a serious skratch in the reputation of your online enterprise. Maybe even worse is beeing part of an Exploit Kit infrastructure, putting all your visitors in harms way for drive-by downloading of malware. 
\\ \\
Even though both SQL Injection and XSS attacks almost as old as the utilazation of databases and javascript in web applications, it still is a major source of vulnerabilities today. 

The basic forms of attacks on both SQL Injection and XSS are easy to pervent, simply by constraining and sanitizing the data. Constrain the length, type, range and possibly format of any input data, and then sanitize the remaining input by escaping characters that could be interpered as code \cite{Bisson2005}. For a query parameter that set the page number in a search funcion, this data should be a integer in the range between 1 and the total number of pages. In a input box in a form, for instance a email, this data should only be accepted if it is a combination of letters and numbers on the format xxx@xxx.xx. Characters like $>$ and $<$ should never be stored as is, but rather changed to their html equvalent or some other form of rewrite   \textbf{Find some sources}. To mitigate the damage from a SQL Injection attack, it's important to do ragularly backups of the database and store passwords using strong and computationally heavy hashing functions with salting.  

This raises the question: why are so many web applications still vulnerable to these types of attacks today? My thoughs on the subject, that in no way is scientificly validated, is that there is two major reasons for this: 1. The web application scene is filled with developers that not nessesarly have a formal education in programming or web development, thus lack the basics like security. 2. An increase in frameworks and content management systems usage silently teaches the developers that the security is taken care of in the core of the framework or CMS, so that when they do create a plugin or special feature they forget to handle these risks themselves.

The JavaScript Libraries on the other hand is harder to pervent, the easiest solution here is to stay on top of all libraries the site is using. Update or remove the library as soon as a bug or vulnerability is found. Another thing that is worth mentioning is that JavaScript libraries could be used in XSS attacks aswell, as seen with jQuery in the Twitter example above.



